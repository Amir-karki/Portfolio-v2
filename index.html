<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="./src/assets/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Amir Karki — Portfolio</title>

    <!-- 1) Pre-apply dark class before paint to avoid flash -->
   <script>
      (function () {
        try {
          const t = localStorage.getItem('theme');
          const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
          if ((t && t === 'dark') || (!t && prefersDark)) {
            document.documentElement.classList.add('dark');
          }
        } catch {}
      })();
    </script>

    <!-- 2) Load Tailwind CDN with proper config -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
      tailwind.config = {
        darkMode: 'class',
        theme: {
          extend: {}
        }
      }
    </script>
  
    <!-- Background animations (pure CSS, low-CPU) -->
    <style>
      /* Fixed, non-interactive layer behind the app */
      .site-bg { position: fixed; inset: 0; pointer-events: none; overflow: hidden; }
      .site-bg .blob { position: absolute; border-radius: 9999px; filter: blur(60px); opacity: .45; transform-origin: 50% 50%; }
      .site-bg .blob.b1 { width: 48rem; height: 48rem; top: -22rem; left: -14rem; background: rgba(240,171,252,.32); animation: blob-rot 48s linear infinite; }
      .site-bg .blob.b2 { width: 56rem; height: 56rem; top: 14rem; right: -18rem; background: rgba(125,211,252,.26); animation: blob-rot-rev 56s linear infinite; }
      .site-bg .blob.b3 { width: 42rem; height: 42rem; left: 38%; bottom: -16rem; background: rgba(110,231,183,.22); animation: blob-rot 60s linear infinite; }
      /* Slightly stronger in dark so they read through dark surfaces */
      .dark .site-bg .blob { opacity: .6; filter: blur(72px); }

      /* Twinkling sparkles using layered radial gradients */
      .site-bg .sparkles { position:absolute; inset:0; mix-blend-mode: screen; opacity:.5; }
      .site-bg .sparkles::before, .site-bg .sparkles::after { content:""; position:absolute; inset:-10% -10%; background-repeat:no-repeat; }
      /* Static layer (lots of faint dots) */
      .site-bg .sparkles::before {
        background-image:
          radial-gradient(2px 2px at 12% 18%, rgba(255,255,255,.45) 0, rgba(255,255,255,0) 60%),
          radial-gradient(2px 2px at 28% 72%, rgba(255,255,255,.35) 0, rgba(255,255,255,0) 60%),
          radial-gradient(2px 2px at 44% 26%, rgba(255,255,255,.4) 0, rgba(255,255,255,0) 60%),
          radial-gradient(2px 2px at 62% 64%, rgba(255,255,255,.38) 0, rgba(255,255,255,0) 60%),
          radial-gradient(2px 2px at 76% 30%, rgba(255,255,255,.42) 0, rgba(255,255,255,0) 60%),
          radial-gradient(2px 2px at 86% 78%, rgba(255,255,255,.33) 0, rgba(255,255,255,0) 60%),
          radial-gradient(2px 2px at 20% 46%, rgba(255,255,255,.36) 0, rgba(255,255,255,0) 60%),
          radial-gradient(2px 2px at 70% 12%, rgba(255,255,255,.34) 0, rgba(255,255,255,0) 60%);
      }
      /* Floating layer (slow drift) */
      .site-bg .sparkles::after {
        background-image:
          radial-gradient(2px 2px at 18% 24%, rgba(255,255,255,.55) 0, rgba(255,255,255,0) 65%),
          radial-gradient(2px 2px at 52% 18%, rgba(255,255,255,.45) 0, rgba(255,255,255,0) 65%),
          radial-gradient(2px 2px at 68% 70%, rgba(255,255,255,.5) 0, rgba(255,255,255,0) 65%),
          radial-gradient(2px 2px at 84% 40%, rgba(255,255,255,.46) 0, rgba(255,255,255,0) 65%),
          radial-gradient(2px 2px at 36% 84%, rgba(255,255,255,.5) 0, rgba(255,255,255,0) 65%),
          radial-gradient(2px 2px at 8% 62%, rgba(255,255,255,.45) 0, rgba(255,255,255,0) 65%);
        animation: spark-float 12s ease-in-out infinite alternate;
      }
      .dark .site-bg .sparkles { opacity:.65; }

      @keyframes blob-rot { from { transform: rotate(0deg) translateZ(0); } to { transform: rotate(360deg) translateZ(0); } }
      @keyframes blob-rot-rev { from { transform: rotate(360deg) translateZ(0); } to { transform: rotate(0deg) translateZ(0); } }
      @keyframes spark-float {
        0% { transform: translateY(0) translateX(0); opacity:.45; }
        50% { transform: translateY(-8px) translateX(6px); opacity:.6; }
        100% { transform: translateY(0) translateX(0); opacity:.45; }
      }
    </style>
  
    <!-- ✨ Shooting-star + fireworks (overlay canvas) -->
    <style>
      /* Hide the previous gradient background without removing it */
      .site-bg { display: none !important; }
      /* Canvas overlay for FX */
      .fx-canvas { position: fixed; inset: 0; pointer-events: none; z-index: 999; }
      @media (prefers-reduced-motion: reduce) { .fx-canvas{ display:none; } }
    </style>

    
  
    <!-- Hero name reveal helper (no React changes) -->
    <style>
      .hero-reveal-target { transition: opacity .7s ease, filter .7s ease; will-change: opacity; }
      body.hide-hero-name .hero-reveal-target { opacity: 0; filter: blur(10px); }
    </style>
  </head>
  <body>
    <!-- Background layer lives behind the React app -->
    <div aria-hidden="true" class="site-bg">
      <div class="blob b1"></div>
      <div class="blob b2"></div>
      <div class="blob b3"></div>
      <div class="sparkles"></div>
    </div>
    <!-- Shooting-star canvas overlay -->
    <canvas id="fx" class="fx-canvas"></canvas><div id="root"></div>
    <script type="module" src="/src/main.jsx"></script>
    
    <!-- Shooting star + fireworks animation (pure JS, single-run reveal) -->
    <script>
      (function () {
        const canvas = document.getElementById('fx');
        if (!canvas || window.__heroRevealRan) return; // guard for HMR
        window.__heroRevealRan = true;

        // Hide hero name until reveal
        document.body.classList.add('hide-hero-name');

        // Wait for the hero <h1> to exist, then tag it so CSS can target it
        function waitForHero(cb) {
          const tryFind = () => {
            const el = document.querySelector('h1');
            if (el) { el.classList.add('hero-reveal-target'); cb(el); return true; }
            return false;
          };
          if (tryFind()) return;
          const mo = new MutationObserver(() => { if (tryFind()) { mo.disconnect(); } });
          mo.observe(document.getElementById('root'), { childList: true, subtree: true });
        }

        const ctx = canvas.getContext('2d');
        let dpr = Math.min(window.devicePixelRatio || 1, 2);
        function resize() {
          const w = window.innerWidth, h = window.innerHeight;
          canvas.width = Math.floor(w * dpr);
          canvas.height = Math.floor(h * dpr);
          canvas.style.width = w + 'px';
          canvas.style.height = h + 'px';
          ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        }
        window.addEventListener('resize', resize, { passive: true });
        resize();

        const particles = [];
        let star = null;
        let done = false;

        function colors() {
          return document.documentElement.classList.contains('dark')
            ? ['#8ab4ff', '#a78bfa', '#60a5fa', '#34d399', '#f0abfc', '#fde047']
            : ['#2563eb', '#7c3aed', '#059669', '#ea580c', '#0ea5e9', '#f59e0b'];
        }

        function explode(x, y) {
          const cols = colors();
          const count = 90;
          for (let i = 0; i < count; i++) {
            const ang = Math.random() * Math.PI * 2;
            const spd = 2 + Math.random() * 6;
            particles.push({
              x, y,
              vx: Math.cos(ang) * spd,
              vy: Math.sin(ang) * spd,
              life: 1,
              decay: 0.008 + Math.random() * 0.02,
              color: cols[i % cols.length],
              size: 1 + Math.random() * 2.2,
            });
          }
          // expanding ring
          particles.push({ x, y, ring: true, r: 0, vr: 7, alpha: 0.55 });

          // Reveal the hero text right at the burst
          document.body.classList.remove('hide-hero-name');

          // Fade the canvas away after a moment and stop the loop
          setTimeout(() => { canvas.style.transition = 'opacity .9s ease'; canvas.style.opacity = '0'; }, 300);
          setTimeout(() => { done = true; }, 1600);
        }

        function fireAt(el) {
          const r = el.getBoundingClientRect();
          const targetX = r.left + r.width / 2;
          const targetY = r.top + r.height / 2; // burst exactly at name center

          // Start from bottom-right offscreen
          const startX = window.innerWidth + 80;
          const startY = window.innerHeight + 50;

          const dx = targetX - startX;
          const dy = targetY - startY;
          const dist = Math.hypot(dx, dy) || 1;
          const speed = 14; // px per frame

          star = {
            x: startX, y: startY,
            vx: (dx / dist) * speed,
            vy: (dy / dist) * speed,
            tx: targetX, ty: targetY,
            trail: []
          };
        }

        function frame() {
          const W = canvas.width / dpr, H = canvas.height / dpr;
          ctx.clearRect(0, 0, W, H);
          ctx.save();
          ctx.globalCompositeOperation = 'lighter';

          if (star) {
            // measure distance BEFORE move
            let dx0 = star.tx - star.x, dy0 = star.ty - star.y;
            let dPrev2 = dx0 * dx0 + dy0 * dy0;

            // advance
            star.x += star.vx; star.y += star.vy;
            star.trail.push([star.x, star.y]);
            if (star.trail.length > 16) star.trail.shift();

            // tail
            for (let i = star.trail.length - 1; i > 0; i--) {
              const [x1, y1] = star.trail[i];
              const [x0, y0] = star.trail[i - 1];
              ctx.strokeStyle = 'rgba(255,255,255,' + (i / star.trail.length * 0.85 + 0.1) + ')';
              ctx.lineWidth = Math.max(1, i * 0.8);
              ctx.beginPath(); ctx.moveTo(x0, y0); ctx.lineTo(x1, y1); ctx.stroke();
            }
            // head
            ctx.fillStyle = '#fff';
            ctx.beginPath(); ctx.arc(star.x, star.y, 2.4, 0, Math.PI * 2); ctx.fill();

            // after move, check if we passed or reached target; if so, snap & explode exactly at target
            let dx1 = star.tx - star.x, dy1 = star.ty - star.y;
            let dNext2 = dx1 * dx1 + dy1 * dy1;
            if (dNext2 <= 16 || dNext2 > dPrev2) {
              star.x = star.tx; star.y = star.ty;
              explode(star.tx, star.ty);
              star = null;
            }
          }

          // particles
          for (let i = particles.length - 1; i >= 0; i--) {
            const p = particles[i];
            if (p.ring) {
              p.r += p.vr; p.alpha *= 0.97;
              ctx.strokeStyle = 'rgba(255,255,255,' + p.alpha + ')';
              ctx.lineWidth = 2;
              ctx.beginPath(); ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2); ctx.stroke();
              if (p.alpha < 0.02) particles.splice(i, 1);
              continue;
            }
            p.vy += 0.04; // gravity
            p.vx *= 0.99; p.vy *= 0.99; // air drag
            p.x += p.vx; p.y += p.vy;
            p.life -= p.decay;
            if (p.life <= 0) { particles.splice(i, 1); continue; }
            ctx.globalAlpha = Math.max(p.life, 0);
            ctx.fillStyle = p.color;
            ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2); ctx.fill();
            ctx.globalAlpha = 1;
          }

          ctx.restore();
          if (!done || particles.length) requestAnimationFrame(frame);
        }

        waitForHero((el) => {
          fireAt(el);
          requestAnimationFrame(frame);
        });

        // Ensure color palette follows theme changes (no heavy work here)
        new MutationObserver(() => {}).observe(document.documentElement, { attributes: true, attributeFilter: ['class'] });
      })();
    </script>

    </body>
</html>
